# ヘッダファイル

C/C++でPythonでの`import`文にあたるのが`#include`文だが、Pythonのimport文とは仕組みが大きくことなる。`#include`は、その名の通り、ファイルをインクルードする仕組みで、インクルードされるファイルをインクルードファイル、もしくはヘッダファイルと呼ぶ。C/C++に慣れていないと、ヘッダファイルをどのように使うべきかよくわからないであろう。

`#include`の動作は非常に単純だが、ヘッダファイルの存在意義を知るためには、分割コンパイルを知る必要があり、分割コンパイルを知るためには、リンクを知る必要があり、リンクを知るためにはそもそも「関数呼び出しとは何か」を知る必要がある。非常に迂遠だが、変に急いでも理解が難しくなるので、一つ一つ説明してみよう。

## 関数呼び出しと分割コンパイル

個人的な意見だが、C/C++を理解するためには、「プログラムもデータも全てメモリ上に存在する」というイメージを掴むのが一番早いと思う。変数がメモリ上に存在するというイメージはつかみやすいが、プログラムもメモリ上に存在している。関数とは、メモリ上のある範囲に住んでいるひと塊のプログラムであり、関数呼び出しとは、その関数の先頭アドレスにジャンプし、最後に戻ってくるという一連の動作のことだ。

こんなコードを見てみよう。単純に二つの変数を受け取って、その和を返す関数`add`を`main`関数から呼び出している。後のために、変数`a`と`b`はグローバル変数として宣言してある。

```cpp
#include <cstdio>

int a = 3, b = 5;

int add(int x, int y) {
  return x + y;
}

int main() {
  int c = add(a, b);
  printf("%d\n", c);
}
```

さて、先に述べたように、プログラムもデータも全てメモリ上に存在している。この`add`や`main`といった関数も、`a`、`b`といった変数も、全てメモリ上にある。メモリには通し番号がついており、その場所を一意に指定できる。この通し番号を「アドレス」もしくは「番地」と呼ぶ。変数も関数もメモリ上に存在するのであるから、当然「メモリ上のどこにあるか」を指定するアドレスを持っている。それを見てみよう。

```cpp
#include <cstdio>

int a = 3, b = 5;

int add(int x, int y) {
  return x + y;
}

int main() {
  int c = add(a, b);
  printf("%d\n", c);
  printf("add : %p\n", add);
  printf("main: %p\n", main);
  printf("a   : %p\n", &a);
  printf("b   : %p\n", &b);
}
```

これは、関数`add`と`main`、変数`a`と`b`のアドレスを表示するものだ。実行してみよう。

```sh
$ g++ call2.cpp
$ ./a.out
8
add : 0x564fa4c3c149
main: 0x564fa4c3c161
a   : 0x564fa4c3f010
b   : 0x564fa4c3f014
```

OSによっては、実行するたびにアドレスが変わるかもしれない。それは「Address Space Layout Randomization (ASLR)」というセキュリティ上の仕組みが走っているためだが、ここでは触れない。いずれにせよ、add, main, a, bがメモリ上にアドレスを持ち、同じような場所に固まって存在している、ということがわかると思う。

![address](fig/address.png)

プログラムはメモリ上にあり、上から順番に解釈、実行されていく。関数とはひとまとまりのプログラムもことであり、関数呼び出しとは、呼び出し元のアドレスを覚えておいて、呼び出す関数のアドレスにジャンプすることだ。飛んだ先で関数の処理が終わったら、先ほど覚えておいたアドレスへと戻ってくる。これが関数呼び出しの仕組みだ。要するに関数呼び出しとは、メモリ上で行って帰ってくるジャンプに過ぎない。
