# 変数宣言とスコープ

変数とスコープの扱いは、プログラミング言語設計者の趣味が大いに反映されるところであり、言語によって差異が非常に大きい。もちろんPythonとC++は扱いが大きく異なる。特にスコープの違いは使用感に大きく影響を与えるため、しっかり理解しておきたい。

## 変数宣言

変数とは、何かの値を表すものだ。「値を入れる箱」と説明されることがあるが、あくまで値の実体はメモリにあり、変数とはそのメモリの場所を指すラベルであると理解してしまった方がよい。どうせC++を学ぶならばメモリの理解は必須だし、Pythonを学ぶ際も変数やリストがどのようにメモリに展開されているかを理解しておかないと「参照rの値渡し」でハマることになる。

さて、新しく変数を作ることを「変数の宣言」と呼ぶ。これは、何かメモリ上の値を保持する場所を用意し、新しくラベルを作ってその場所を指すことである。変数の宣言方法には、大きくわけて二種類ある。一つは「初めて変数が使われた時に作る派」であり、PythonをはじめとしてPerl、Rubyといったスクリプト言語系は概ねこの立場をとる。もう一つは「変数を新たに作ることを陽に宣言する派」であり、C++をはじめとしてJava等のコンパイル言語系は概ねこの立場だ。

例えば、Pythonにおいては「変数宣言」は値の代入を兼ねる。

```py
a = 1 # ここで変数aが作られ、初期値1が代入される
a = 2 # ここでは既にある変数aの値が更新される
```

このようにPythonでは「最初に使われた時」に変数が宣言される。

一方、C++は変数宣言のための構文がある。

```cpp
int a;
```

これは、「`int`型の変数`a`を作る」という宣言である。この時点で、メモリ上に`int`の値を保持できる領域(通常4バイト)が確保され、`a`を通じて利用可能になる。ただし、`a`にはじめどんな値が入っているかは不定である。

変数宣言をせずに変数を使おうとするとコンパイルエラーになる。

```cpp
a = 1; // error: 'a' was not declared in this scope
```

ここで「このスコープでは定義されていない」というエラーに注目して欲しい。スコープとは変数の名前が有効な範囲であり、後で詳述する

変数宣言後なら値の代入ができる。

```cpp
int a;
a = 1;
```

変数宣言と値の代入を同時に行うこともできる。

```cpp
int a = 1;
```

初期値の入っていない変数の値は不定であり、思わぬバグの元になるため、通常は変数宣言と同時に値の代入を行う。

## スコープ

変数は、その名前が有効な範囲があり、それをスコープと呼ぶ。例えばPythonでも、関数の中で宣言された変数を、その外で使うことはできない。

```py
def func():
    a = 1

func()
print(a)   # => NameError: name 'a' is not defined
```

このコードでは、関数`func`の中で変数`a`を宣言、初期化しているが、関数`func`を呼び出した後でも、その変数`a`を使うことはできない。関数の中で宣言された変数名が有効なのは関数の中だけだからだ。一般に、変数のスコープが広いほど思わぬバグの原因になるため、出来る限りスコープを狭くとるようにプログラムを組む。

C++でも、変数のスコープが関数内に限定されるのはPythonと同じである。

```cpp
void func(){
  int a = 1;
}

int main(){
  func();
  printf("%d\n",a); // エラー
}
```

しかし、C++の変数のスコープはPythonよりも細かく、ブロック単位となる。プログラムにおいて、実行のまとまりをブロックと呼ぶ。Pythonでは、同じインデントになっている場所が同じブロックである。例えば、if文やwith文など、コロンで終わる構文はブロックを伴う。

```py
if a % 2:
    print("a is odd.")
else:
    print("a is even.")
```

Pythonではif文はスコープを作らない。したがって、if文の中で宣言された変数をif文の外で使うことができる。

```py
a = 1

if a % 2:
    msg = "Odd"
else:
    msg = "Even"

print(msg) # => Odd
```

ここでは、if文の中で宣言された`msg`という変数を、if文の外で使うことができている。

C++では、中カッコ`{}`で囲まれた部分がブロックを作る。ここで、Pythonとの大きな違いは、if文などが作るブロックが、スコープを作ることだ。

```cpp
int a = 1;
if (a % 2) {
  const char *msg = "Odd";
} else {
  const char *msg = "Even";
}
puts(msg); // => error: ‘msg’ was not declared in this scope
```

C++では、if文に限らず、ただ中カッコで囲むだけでスコープを作ることができる。

```cpp
int main(){
  {
    int a = 1;
    printf("%d\n",a); #=> 1
  }
  // ☆
}
```

ここでは、`main`関数の中にさらに中カッコで囲んだ領域を作ってその中で変数`a`を宣言している。この`a`のスコープは内側の中カッコに限定され、☆の場所では使うことができない。

また、スコープがネストした場合、C++では内側のスコープは外側のスコープの変数を隠蔽する。例えばこんなコードを見てみる。

```cpp
#include <cstdio>

int main() {
  int a = 1; // A
  {
    int a = 2; // B
    printf("a = %d\n", a); // => 2
  }
  printf("a = %d\n", a); // => 1
}
```

A地点で宣言された変数は、内側のスコープのB地点で変数宣言をした時点で隠蔽される。この時点で、外側のスコープの変数`a`を触ることはできなくなる。スコープを抜けた後は、A地点での変数が有効になるため、二回目のprintf文ではA地点で代入された値が表示される。

こういう、変数名が与えられた時、それがどの場所で宣言された変数なのかを調べる仕組みを「名前解決」いう。繰り返しになるが、スコープの扱いと名前解決の扱いはプログラミング言語設計者の趣味が強くでるため、言語によって差異が大きい。

## グローバル変数の扱い

スコープの中で、一番外側のスコープをグローバルスコープと呼ぶ。グローバルスコープに住む変数をグローバル変数と呼ぶ。C++なら全ての関数の外側で宣言された変数、Pythonなら全くインデントされていない場所で宣言された変数がグローバル変数である。それに対して、関数内など、内側のスコープで宣言された変数をローカル変数と呼ぶ。

先ほど触れたように、外側のスコープで宣言された変数と同じ名前の変数を内側のスコープで宣言した場合、外側のスコープの変数が隠蔽される。PythonとC++でグローバル変数をローカル変数で隠蔽した時の振る舞いが違うため、それについて少し触れておく。

Pythonでは、変数の代入が変数宣言を兼ねる。したがって、変数の代入文があった時、それが既存の変数への代入を意図したものか、新たに変数を宣言して初期値を代入することを意図したものかが判断できない。そのため、関数内でグローバル変数をいじろうとして、実はいじれてない、というバグを入れる場合がある。

```py
a = 1

def func():
    a = 2

func()
print(a)  #=> 1
```

上記のコードは、関数`func`の中でグローバル変数`a`の値を修正する意図で書いたものだが、実はローカル変数`a`を作っており、実際にはグローバル変数`a`の値は修正されない。こういうふうに書くとわかりやすいが、例えばグローバルスコープにベタにかいたコードを、関数に逃がした場合にこういうことがよく起きる。

Pythonでは、これが変数宣言ではなく、グローバル変数を触る意図なのだとプログラマが明示するために`global`宣言を用意している。

```py
a = 1

def func():
    global a
    a = 2

func()
print(a) # => 2
```

関数`func`の中に`global a`という宣言があるため、これによってPython処理系はあなたがローカル変数を宣言したのではなく、グローバル変数を触りにいきたいのだと理解できる。

なお、C++では、変数宣言は必ず`int a`のように型名を伴うため、変数宣言なのか代入なのかの混乱は起きず、結果として`global`宣言などは不要である。

## switch文

C++では、原則として何か文法構造はブロックを作り、変数のスコープはそのブロック内に限定される。しかし、例外的にブロックを作らない文法構造がある。それがswitch文である。

switch文は、こんな文法である。

```cpp
switch (var){
  case v1:
    puts("var is v1.");
  break;
  case v2:
    puts("var is v2.");
  break;
}
```

`switch(変数)`という形で、変数の値について分岐することを宣言し、その後`case 値:`という形で、変数がその値だった時の処理を記述していく。例えばこんな風に使う。

```cpp
#include <cstdio>
#include <random>

int main() {
  std::mt19937 mt;
  std::uniform_int_distribution<int> ud(1, 3);
  for (int i = 0; i < 10; i++) {
    int r = ud(mt);
    switch (r) {
    case 1:
      puts("One");
      break;
    case 2:
      puts("Two");
      break;
    case 3:
      puts("Three");
      break;
    }
  }
}
```

1から3までランダムな値を取る変数`r`をswitch文の中にいれている。もし`r==1`なら、`case 1:`のところにジャンプする。

ここで注意すべきなのは、`case hoge:`という部分はブロックを作らず、したがってスコープも作らないことだ。したがって、このcase文の中で変数宣言をしようとするとエラーになる。

```cpp
void func(int a) {
  switch (a) {
  case 1:
    int b = 2;
    printf("%d\n", b);
    break;
  case 2:  // => ここでコンパイルエラー
    puts("One");
    break;
  }
}
```

エラーメッセージはこんな感じだ。

```sh
$ g++ -c switch_scope.cpp
switch_scope.cpp: In function ‘void func(int)’:
switch_scope.cpp:9:8: error: jump to case label
    9 |   case 2:
      |        ^
switch_scope.cpp:6:9: note:   crosses initialization of ‘int b’
    6 |     int b = 2;
      |         ^
```

このエラーメッセージの意味は、「switchでジャンプするラベルが、変数宣言を飛び越える可能性があるよ」という意味だ。もし`a=2`の場合、変数宣言`int b=2`を飛び越えてしまう。すると、その後で`b`を使おうとするとおかしなことになる。これは、C++のswitch文がスコープを使わず、かつ「ラベルへのジャンプ」で実装されているためだ。

古の時代、プログラムの分岐はgotoとラベルで行われていた。goto文をサポートしない言語は多いが、C/C++はまだサポートしている。

```cpp
#include <cstdio>

void func(int a) {
  if (a % 2)
    goto even;
  else
    goto odd;
even:
  puts("Even");
  return;
odd:
  puts("Even");
}

int main(){
  func(2);
}
```

関数`func`は、`a`の偶奇によりラベル`even`か`odd`にジャンプする。このコードは現在でも全く問題なくコンパイル、実行できる。goto文にはいろいろな問題があり、ダイクストラによる「Go To Statement Considered Harmful」という文章は有名であるが、とりあえずここでは「go to 文による制御構造がスコープを作らない」ことを問題視する。

現在では、先のコードは以下のように書く。

```cpp
void func(int a){
  if (a % 2){
    puts("Even");
  }else{
    puts("Odd");
  }
}
```

このコードは制御構造がブロックを、そしてそのブロックがスコープを作っており、変数が迷子になったりしない。

以上を鑑みて、もう一度switch文を見てみよう。

```cpp
void func(int a) {
  switch (a) {
  case 1:
    int b = 2;
    printf("%d\n", b);
    break;
  case 2:  // => ここでコンパイルエラー
    puts("One");
    break;
  }
}
```

この`case 1:`はラベルであり、switch文はジャンプ、すなわちgoto文として実装されている。そのためにブロックを作らず、結果としてスコープも作らないので、「switch文の中身によっては、変数宣言をすっ飛ばす可能性」が出てきてしまう。

この問題の解決方法は二つある。変数宣言をふっ飛ばす可能性が問題なのだから、問題のcase文が最後にあれば問題ない。

```cpp
void func(int a) {
  switch (a) {
  case 2: // 順番を入れ替えた
    puts("One");
    break;
  case 1:
    int b = 2;
    printf("%d\n", b);
    break;
  }
}
```

「え？それでいいの？」と思うかもしれないが、問題なくコンパイル、実行できる。

しかし、この方法では二つ以上のcase文で変数宣言をしている場合には使えない。そういう場合は、中カッコでブロックを作ってしまえばよい。

```cpp
void func(int a) {
  switch (a) {
  case 1: {// ブロックを作った
    int b = 2;
    printf("%d\n", b);
    break;
  }
  case 2:  // => エラーにならない
    puts("One");
    break;
  }
}
```

これもやはりエラーにならない。

ついでに、switch文はあくまで「ジャンプ」なので、何もしないと飛んだ先で次のラベルに進んでしまう。

たとえばこんなコードを見てみよう。

```cpp
#include <cstdio>

int main() {
  int a = 0;
  switch (a) {
  case 0:
    puts("a is 0");
  case 1:
    puts("a is 1");
  case 2:
    puts("a is 2");
  }
}
```

これは、変数`a`が0なら`a is 0`、1なら`a is 1`、2なら`a is 2`を表示させる意図で書かれたものだが、これを実行すると全て表示されてしまう。

```sh
$ g++ fall_through.cpp
$ ./a.out
a is 0
a is 1
a is 2
```

これは、`a==0`の時、`case 0:`にジャンプするが、そのまま処理が進んで`case 1:`のラベルの下の処理も実行してしまうためだ。これをswitch文の**フォールスルー(fall through)**と呼ぶ。意図的にこのような処理を実行する場合もあるが、多くの場合はバグのもとなので、やらない方がよい。次のラベルに処理が進むのを防ぐためには、ラベルの最後で`break`する。

```cpp
#include <cstdio>

int main() {
  int a = 0;
  switch (a) {
  case 0:
    puts("a is 0");
    break;
  case 1:
    puts("a is 1");
    break;
  case 2:
    puts("a is 2");
    break;
  }
}
```

breakは、外側のswitch文やfor、whileといったループ文を抜けるための処理だ。switch文を使うことは少ないと思われるが、もし使う場合は必ずbreakを入れること、さらに、case文の中で変数宣言をしたらエラーになるので、どうしてもやりたい場合は中カッコでブロックを作ることを覚えておくと良い。

## 変数宣言の位置とfor文

現在のC/C++では、変数をどこで宣言しても良いことになっている。変数のスコープは、「変数を宣言した位置から、そのブロックが終わるまで」だ。しかし、太古のC言語では、変数宣言が関数の冒頭になければならない、という制約があった。なので、古いコードでこんな書き方を目にすることがある。

```cpp
void func(){
  int i,j,k;
  float temp;
  double hogehoge;
  for (i = 0; i< N ;i ++){
    // ...
  }
  // ...
}
```

関数の冒頭で、変数がまとめて宣言されている。現代では、このような書き方はせず、変数は使う場所で宣言し、かつ宣言と同時に初期化をするのが一般的である。

さて、通常、変数のスコープは中カッコが作るブロックの中に限定される。

```cpp
if (hogehoge){
  ...
  ...
  int a; // aの有効範囲ここから
  ...
  // ここまで
}
```

さて、for文の文法はこうであった。

```cpp
for(変数の初期化; 続行条件; ループごとの変数の修正){
  ループの中身
}
```

ここで、ループの内側の中カッコでブロックを作る気がするので、for文のループ変数はその外側で宣言したくなる。

```cpp
int i;
for(i=0;i<N;i++){
  ループの中身
}

// ここでもiが有効
```

こうすると、ループ変数`i`はループの中でしか使わないのに、ループ終了後もいじることができる。これは特に似たようなループが複数回続く時にバグのもとである。そこで、C/C++ではforの中で変数宣言ができる。

```cpp
for(int i=0;i<N;i++){ //変数の初期化の場所で変数宣言
  ループの中身
} //　i のスコープここまで

// ここではiは見えない
```

ループ変数をループ内しか使わないのであれば、`for(int i=0)`と、for文の中で宣言する癖をつけておきたい。

## まとめ

C++とPythonの変数宣言の違いとスコープの違いを見た。C++変数宣言と代入が区別されているが、Pythonでは区別がないため、たとえばグローバル変数をローカル変数で隠蔽する際に違いが出る。また、Pythonはif文などのブロックがスコープを作らないが、C++は作る。したがって、いくらでもスコープがネストする。原則としてC++の文法構造はスコープを作るが、switch文は作らないため、case文の中で変数を宣言するとエラーとなる場合がある。どれもつまらないことだが、知らないとハマった時に困るので、頭の片隅に入れておきたい。