# C++の闇について

他の言語と比べて特別に深いかはわからないのだが、C++には闇がある。特に「処理系依存」と「未定義動作」まわりは闇が深い。

例えば、C++は「型」のサイズが決まっていない。実数型には、`float`、`double`、`long double`の三種類があり、`float`を単精度、`double`を倍精度と呼ぶことから、`double`は`float`の倍のサイズを持つと期待され、多くの実装ではそうなっている。

しかし、言語仕様としては、

```txt
float <= double <= long double
```

であることだけが規定されており、それぞれの実際のサイズは規定されていない。特に`long double`の実装は処理系依存であり、`double`と`long double`は同じサイズにとる処理系が多いが、x86系では`long double`は10バイトであるが、`sizeof(long double)`は16になる。つまり「16バイトを確保するが、実際に使うのは10バイト」である。

そもそも、C/C++では1バイトが何ビットであるかも決まっていない。多くの処理系では「1バイトは8ビット」であるが、言語仕様として決まっているのは「`char`のサイズが1バイト」であることだけで、`char`が何ビットであるかは決まっていない。

筆者は「`char`は1バイトで、1バイトは8ビット」とある記述に、わざわざ「`char`は8ビットとは限らない」などと指摘するような人を苦々しく思っているが、C++に闇があることは事実だし、闇は闇として知っておくのも悪くは無かろう。

以下ではC++の闇の例をいくつか紹介する。ただし、初学者はとりあえず気にしなくて良い。

## 処理系依存の動作について

C++には、処理系に依存する動作がある。言語として規定されていないが、処理系としては定義されている動作に「処理系定義の動作 (implementation-defined behavior)」がある。例えば[こんなもの](http://www.c-lang.org/detail/implementation_defined_behavior.html)が処理系に依存する。

処理系定義の動作でもっとも身近なのは、エラーメッセージだろう。

例えばこんなコードをコンパイルしてみよう。

```cpp
#include <cstdio>

int main() {
  int i = 0;
  int i = 1;
}
```

clang++の9.0.0では以下のようなエラーが出る。

```txt
prog.cc:5:7: error: redefinition of 'i'
  int i = 1;
      ^
prog.cc:4:7: note: previous definition is here
  int i = 0;
      ^
1 error generated.
```

g++の9.3.0ではこんなエラーになる。

```txt
prog.cc: In function 'int main()':
prog.cc:5:7: error: redeclaration of 'int i'
    5 |   int i = 1;
      |       ^
prog.cc:4:7: note: 'int i' previously declared here
    4 |   int i = 0;
      |       ^
```

同じGCCでも、g++の7.3.0はこんなエラーだ。

```txt
prog.cc: In function 'int main()':
prog.cc:5:7: error: redeclaration of 'int i'
   int i = 1;
       ^
prog.cc:4:7: note: 'int i' previously declared here
   int i = 0;
       ^
```

さて、正確には処理系定義動作ではなく(多分)未定義動作となるが、実質的には処理系に依存する動作の例として、`printf`のフォーマット文字列と引数の型の順番が整合していない場合が挙げられる。

`printf`は、最も良く使う関数だ。フォーマット文字列と呼ばれる文字列と、複数の変数を受け渡して、結果を出力する。例えば、整数は`%d`を指定する。

```cpp
printf("%d\n",3); // 3が表示される。
```

浮動小数点数なら`%f`だ。

```cpp
printf("%f\n",1.2); // 1.2が表示される。
```

また、複数の変数を指定することもできる。

```cpp
printf("%f %d\n",1.2, 3); // 1.2 3が表示される。
```

さて、問題は、フォーマット文字列の型と、引数の型の順番が整合していない場合だ。先の例のフォーマット文字列の順番を入れ替えて見る。

```cpp
printf("%d %f\n",1.2, 3); 
```

なんとなく、1.2を整数に丸め、3を浮動小数だと思って解釈し、「1 3」と表示されて欲しい気がする。しかし、実際には「3 1.2」と順番が入れ替わって表示される。

これには深淵な理由があるのだが、ここでは詳細は説明しない。詳しくは[Cの可変長引数とABIの奇妙な関係](https://qiita.com/qnighy/items/be04cfe57f8874121e76)という記事を参照して欲しい。

なお、Pythonで同様なことをすると、期待する動作となる。

```py
print("%d %f" % (1.2, 3)) #=> 1 3.000000
```

すなわち、1.2を整数に丸め、3は浮動小数と解釈されている。

## 未定義動作について

仕様に定義されておらず、処理系でも定義されない動作を「未定義動作 (undefined behavior)」と呼ぶ。未定義動作は、結果が定義されていないため、結果として何が起きてもプログラマは文句を言うことができない。これを指して「鼻から悪魔」と呼ぶ。これは、動作が定義されていないのだから、プログラムを実行した結果、プログラマの鼻から悪魔が出てこようが文句は言えないよ、というジョークのようなものだ。

未定義動作は、例えば実行するたびに結果が異なったり、エラーでプログラムが止まったり、暴走したりする。特に最近困るのは、コンパイラが未定義動作を積極的に最適化に利用することだ。すると、コンパイラが最適化をするかどうかで結果が変わることになる。これを見てみよう。


### ヌルポインタのデリファレンス

C++では、変数に`&`をつけることで、そのアドレスを得ることができる。そのアドレスは、その変数の型のポインタで受け取ることができる。

```cpp
int a = 1; 
int *p = &a;
```

上記の例では、`int`型を指すポインタ`p`を定義し、`int`型の変数`a`のアドレスを代入している。

さて、`p`はアドレスを指しているが、このポインタの指す先の値を参照するには、`*p`と、`*`をつけてやれば良い。

```cpp
printf("%d\n", *p); // 1と表示される
```

これを「ポインタのデリファレンス(間接参照)」と呼ぶ。

さて、C++にはヌルポインタというものがある。値として`NULL`と言う定数を指すポインタだ。

```cpp
int *p = NULL;
```

C++では、ヌルポインタのデリファレンスは未定義動作となる。それが最適化とからむとどうなるかを見てみよう。こんなコードを書いてみる。

```cpp
#include <cstdio>

void func(int &v) {
  if (&v == NULL) {
    printf("v is NULL!\n");
  } else {
    printf("v is not NULL!\n");
  }
}

int main(void) {
  int *p = NULL;
  func(*p);
}
```

関数`func`は、受け取った変数のアドレスを参照し、NULLかどうかを判定する関数だ。それにヌルポインタ`p`を定義し、それをデリファレンスして関数`func`に与えている。

これを最適化レベル1まででコンパイル、実行すると、受け取った変数のアドレスはNULLだと表示する。

```sh
$ g++ -O1 null.cpp
$ ./a.out
v is NULL!
```

しかし、最適化レベルを上げると、NULLじゃないよ、と表示するようになる。

```sh
$ g++ -O2 null.cpp
v is not NULL!
```

なぜこうなるのか。最適化レベルを上げると、コンパイラは関数`func`を見てこう思う。

```cpp
void func(int &v) {
  if (&v == NULL) {
    printf("v is NULL!\n");
  } else {
    printf("v is not NULL!\n");
  }
}
```

関数`func`は、変数`v`を参照渡しで受け取っている。その後、その変数のアドレスを見て、NULLかどうかを調べている。しかし、もし変数`v`のアドレスがNULLであるならば、最初にヌルポインタがデリファレンスされて引数として渡されてきたことになる。ヌルポインタのデリファレンスは未定義動作で、何が起きてもプログラマは文句は言えない。そこで、コンパイラは「未定義動作は起きないものだ」と仮定してよい。

以上から、コンパイラは関数`func`を以下のように修正できる。

```cpp
void func(int &) {
  printf("v is not NULL!\n");
}
```

以上が最適化レベルを上げたときに起きることだ。最適化レベルが低い場合は真面目にポインタをデリファレンスしてNULLかどうかを判定するコードを吐くので、最適化レベルによって結果が変わる、ということが起きる。

### 返り値を返さない関数

C++は、関数が値を返す場合はその型を明示しなければならない。例えば整数を返す関数は、関数の名前の左側に返り値の型`int`を置く。

```cpp
int add(int a, int b){
  return a + b;
}
```

これは、整数を二つ受け取り、その和を返す関数だ。

さて、値を返すと宣言しながら、値を返さない関数を考える。例えばこんな関数だ。

```cpp
int func(void){
  print("Hello\n");
}
```

「整数を返す関数だよ」と宣言しているにも関わらず、return文が無い。実はこれは、未定義動作となる。

例えばこんなコードを考える。

```cpp
#include <cstdio>

int foo(void) {
  printf("foo\n");
}

void bar() {
  printf("bar\n");
  foo();
}

int main() {
  foo();
}
```

`main`関数は`foo`という関数を呼んでいるだけである。`foo`という関数は、整数を返すと定義されているにも関わらず`return`文が無い。また、`foo`の下には、このプログラムでは呼ばれない`bar`という関数がある。

このプログラムを、最適化無しでコンパイルすると、想定通り`foo`とだけ表示される。

```sh
$ g++ foobar.cpp
$ ./a.out
foo
```

しかし、GCC 8.0以上で、最適化オプション`-O1`以上をつけてコンパイル、実行すると、`foo`と`bar`を交互に、無数に表示して、最後はエラーで落ちる。

```sh
$ g++ -O1 foobar.cpp
$ ./a.out
foo
bar
foo
bar
(snip)
foo
bar
foo
bar
zsh: segmentation fault  ./a.out
```

直接的な理由は「[MacのGCCで返り値を返さない関数を書くと鼻から悪魔が出る](https://qiita.com/kaityo256/items/477d38030505d8fec6e3)」を参照してもらうとして、本質的には未定義動作を見つけたコンパイラが好き勝手しているのが原因だ。

### 無限ループは存在しない

C++では、「無限ループは存在しない(全ての処理は終了する)」と仮定して良いことになっている。したがって、無限ループは未定義動作となる。それを利用すると、奇数は偶数であることが証明できる。

こんなコードを書いてみよう。

```cpp
#include <cstdio>

bool is_even(int a) {
  while (a % 2 != 0) {
    a += 2;
  }
  return true;
}

int main() {
  if (is_even(1)) {
    printf("Odd is even!\n");
  }
}
```

関数`is_even`は、整数`a`を受け取り、それが偶数で無い間、2を足し続ける関数だ。

当然、最初に受け取ったのが奇数であれば、2を足しても奇数であるから、このwhileループは終了せず、無限ループとなる。実際、このコードを最適化無しでコンパイルして実行すると終了しない。

しかし、最適化レベルを上げるとこのコードは終了し、高らかに「Odd is even!(奇数は偶数だ！)」と宣言する。

```sh
$ g++ -O2 odd_is_even.cpp
$ ./a.out
Odd is even!
```

なぜか。最適化レベルを上げると、コンパイラは以下のように考える。関数`is_even`が終了するのは、`while`ループを抜けた時だけだ。そして、ループを抜けた時、返す値は`true`しかない。「全ての処理は終了する」、すなわち、この`while`ループは「いつか終わる」と仮定してよい。ならば即座に`true`を返せば良いではないか。

以上の推論から、コンパイラは関数`is_even`を次のように変更してしまう。

```cpp
bool is_even(int){
  return true;
}
```

だいぶすっきりしてしまった。

詳細については[この記事](https://qiita.com/tkmtSo/items/de3148dd1dcb70f38d6a)を参照されたい。


## まとめ

個人的にC++の闇と思われるところを列挙してみた。繰り返しになるが、このような「不可思議な動作」は初学者の学習の妨げとなるので、あまり最初から強調すべきではない。無論、ほとんどの場合において「不可思議な動作」は、単にプログラマがいれたバグに起因する。しかし、C++の学習が進み、数値計算などでコードの最適化を気にし始めると、意外にこのような闇が身近にあると感じる。最初は気にしてはいけないが、「闇がある」ということは頭の片隅にいれておいても良いかもしれない。

