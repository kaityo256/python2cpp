# 変数宣言とスコープ

変数とスコープの扱いは、プログラミング言語設計者の趣味が大いに反映されるところであり、言語によって差異が非常に大きい。もちろんPythonとC++は扱いが大きく異なる。特にスコープの違いは使用感に大きく影響を与えるため、しっかり理解しておきたい。

## 変数宣言

変数とは、何かの値を表すものだ。「値を入れる箱」と説明されることがあるが、あくまで値の実体はメモリにあり、変数とはそのメモリの場所を指すラベルであると理解してしまった方がよい。どうせC++を学ぶならばメモリの理解は必須だし、Pythonを学ぶ際も変数やリストがどのようにメモリに展開されているかを理解しておかないと「参照の値渡し」でハマることになる。

さて、新しく変数を作ることを「変数の宣言」と呼ぶ。これは、何かメモリ上の値を保持する場所を用意し、新しくラベルを作ってその場所を指すことである。変数の宣言方法には、大きくわけて二種類ある。一つは「初めて変数が使われた時に作る派」であり、PythonをはじめとしてPerl、Rubyといったスクリプト言語系は概ねこの立場をとる。もう一つは「変数を新たに作ることを陽に宣言する派」であり、C++をはじめとしてJava等のコンパイル言語系は概ねこの立場だ。

例えば、Pythonにおいては「変数宣言」は値の代入を兼ねる。

```py
a = 1 # ここで変数aが作られ、初期値1が代入される
a = 2 # ここでは既にある変数aの値が更新される
```

このようにPythonでは「最初に使われた時」に変数が宣言される。

一方、C++は変数宣言のための構文がある。

```cpp
int a;
```

これは、「`int`型の変数`a`を作る」という宣言である。この時点で、メモリ上に`int`の値を保持できる領域(通常4バイト)が確保され、`a`を通じて利用可能になる。ただし、`a`にはじめどんな値が入っているかは不定である。

変数宣言をせずに変数を使おうとするとコンパイルエラーになる。

```cpp
a = 1; // error: 'a' was not declared in this scope
```

ここで「このスコープでは定義されていない」というエラーに注目して欲しい。スコープとは変数の名前が有効な範囲であり、後で詳述する

変数宣言後なら値の代入ができる。

```cpp
int a;
a = 1;
```

変数宣言と値の代入を同時に行うこともできる。

```cpp
int a = 1;
```

初期値の入っていない変数の値は不定であり、思わぬバグの元になるため、通常は変数宣言と同時に値の代入を行う。

## スコープ

変数は、その名前が有効な範囲があり、それをスコープと呼ぶ。例えばPythonでも、関数の中で宣言された変数を、その外で使うことはできない。

```py
def func():
    a = 1

func()
print(a)   # => NameError: name 'a' is not defined
```

このコードでは、関数`func`の中で変数`a`を宣言、初期化しているが、関数`func`を呼び出した後でも、その変数`a`を使うことはできない。関数の中で宣言された変数名が有効なのは関数の中だけだからだ。一般に、変数のスコープが広いほど思わぬバグの原因になるため、出来る限りスコープを狭くとるようにプログラムを組む。

C++でも、変数のスコープが関数内に限定されるのはPythonと同じである。

```cpp
void func(){
  int a = 1;
}

int main(){
  func();
  printf("%d\n",a); // エラー
}
```

しかし、C++の変数のスコープはPythonよりも細かく、ブロック単位となる。プログラムにおいて、実行のまとまりをブロックと呼ぶ。Pythonでは、同じインデントになっている場所が同じブロックである。例えば、if文やwith文など、コロンで終わる構文はブロックを伴う。

```py
if a % 2:
    print("a is odd.")
else:
    print("a is even.")
```

Pythonではif文はスコープを作らない。したがって、if文の中で宣言された変数をif文の外で使うことができる。

```py
a = 1

if a % 2:
    msg = "Odd"
else:
    msg = "Even"

print(msg) # => Odd
```

ここでは、if文の中で宣言された`msg`という変数を、if文の外で使うことができていｒ。

C++では、中カッコ`{}`で囲まれた部分がブロックを作る。ここで、Pythonとの大きな違いは、if文などが作るブロックが、スコープを作ることだ。

```cpp
int a = 1;
if (a % 2) {
  const char *msg = "Odd";
} else {
  const char *msg = "Even";
}
puts(msg); // => error: ‘msg’ was not declared in this scope
```

C++では、if文に限らず、ただ中カッコで囲むだけでスコープを作ることができる。

```cpp
int main(){
  {
    int a = 1;
    printf("%d\n",a); #=> 1
  }
  // ☆
}
```

ここでは、`main`関数の中にさらに中カッコで囲んだ領域を作ってその中で変数`a`を宣言している。この`a`のスコープは内側の中カッコに限定され、☆の場所では使うことができない。

また、スコープがネストした場合、C++では内側のスコープは外側のスコープの変数を隠蔽する。例えばこんなコードを見てみる。

```cpp
#include <cstdio>

int main() {
  int a = 1; // A
  {
    int a = 2; // B
    printf("a = %d\n", a); // => 2
  }
  printf("a = %d\n", a); // => 1
}
```

A地点で宣言された変数は、内側のスコープのB地点で変数宣言をした時点で隠蔽される。この時点で、外側のスコープの変数`a`を触ることはできなくなる。スコープを抜けた後は、A地点での変数が有効になるため、二回目のprintf文ではA地点で代入された値が表示される。

こういう、変数名が与えられた時、それがどの場所で宣言された変数なのかを調べる仕組みを「名前解決」いう。繰り返しになるが、スコープの扱いと名前解決の扱いはプログラミング言語設計者の趣味が強くでるため、言語によって差異が大きい。

## グローバル変数の扱い

スコープの中で、一番外側のスコープをグローバルスコープと呼ぶ。グローバルスコープに住む変数をグローバル変数と呼ぶ。C++なら全ての関数の外側で宣言された変数、Pythonなら全くインデントされていない場所で宣言された変数がグローバル変数である。それに対して、関数内など、内側のスコープで宣言された変数をローカル変数と呼ぶ。

先ほど触れたように、外側のスコープで宣言された変数と同じ名前の変数を内側のスコープで宣言した場合、外側のスコープの変数が隠蔽される。PythonとC++でグローバル変数をローカル変数で隠蔽した時の振る舞いが違うため、それについて少し触れておく。

Pythonでは、変数の代入が変数宣言を兼ねる。したがって、変数の代入文があった時、それが既存の変数への代入を意図したものか、新たに変数を宣言して初期値を代入することを意図したものかが判断できない。そのため、関数内でグローバル変数をいじろうとして、実はいじれてない、というバグを入れる場合がある。

```py
a = 1

def func():
    a = 2

func()
print(a)  #=> 1
```

上記のコードは、関数`func`の中でグローバル変数`a`の値を修正する意図で書いたものだが、実はローカル変数`a`を作っており、実際にはグローバル変数`a`の値は修正されない。こういうふうに書くとわかりやすいが、例えばグローバルスコープにベタにかいたコードを、関数に逃がした場合にこういうことがよく起きる。

Pythonでは、これが変数宣言ではなく、グローバル変数を触る意図なのだとプログラマが明示するために`global`宣言を用意している。

```py
a = 1

def func():
    global a
    a = 2

func()
print(a) # => 2
```

関数`func`の中に`global a`という宣言があるため、これによってPython処理系はあなたがローカル変数を宣言したのではなく、グローバル変数を触りにいきたいのだと理解できる。

なお、C++では、変数宣言は必ず`int a`のように型名を伴うため、変数宣言なのか代入なのかの混乱は起きず、結果として`global`宣言などは不要である。

## switch文

